预解析时形参也要参与
全局作用域代码执行过程(先全局预解析，然后全局进行代码执行，当执行到函数调用的时候，在函数内部会先进行预解析，然后再执行)
如果第一个参数是普通对象,那么push.apply的作用实际上就是属性覆盖
作用域：
1.全局作用域
2.函数作用域
js中没有块级作用域
{
    var abc=123;
    console.log(abc);
    //这就是块级作用域

}
里面可以访问外面 外面访问不了里面的作用域
 作用域链：
 函数内层作用域可以访问外层作用域，但是反过来不行
 平行(平级之间是不能相互访问的)；
 js运行分为两个阶段：
 1.预解析
 全局预解析(所有的变量和函数声明都会提前,同名的函数和变量函数的优先级高)
 函数内部预解析(所有的变量、函数和形参都会预解析：优先级：函数--形参---变量)；
 
 2.执行
 先解析全局作用域，然后再执行全局作用域中的代码，在执行全局代码的过程中遇到函数调用就会先进行函数预解析，然后再执行函数内的代码
 闭包：封闭的区域
 函数的嵌套形成闭包(内层函数和内层函数所处的作用域)
 闭包可以操作函数内部的变量(间接的)
 闭包可以延长变量的生命周期，但是占用了更多的内存
 闭包可以缓存中间状态值(内存开销大了)
 var arr = [];
    for (var i = 0; i < 3; i++) {
        arr[i] = (function (num) {
            return function () {
                console.log(num);
            }
        })(i);//i为实参
    }

    arr[0]();//0
    arr[1]();//1
    arr[2]();//2

 function foo(){
     var num=123;
     return num;
     //不能修改 return不了简单类型
 }
 var flag=foo();
 console.log(flag);//123





